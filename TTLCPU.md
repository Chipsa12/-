# Описание

TTLCPU помещается на небольшой макетной плате и разработан так, что может выполнять сложные программы на Си, не используя микрокод.

Программы записываются на Си-подобном языке и компилируются, используя специально разработанный набор утилит, который содержит ассемблер, Си-подобный компилятор и некоторые библиотечные процедуры и макросы.

# Архитектура

Так как этот ЦП не использует микрокод, он может выполнять только одну элементарную операцию: перемещать данные во время каждого цикла инструкции из источника данных в приёмник. Вообще говоря, на аппаратном уровне каждая инструкция ЦП представляет собой операцию перемещения, код инструкции определяет компонент-источник данных (в т.ч. аккумулятор, порт ввода, память данных, память программ и т.д.) и компонент-приёмник (аккумулятор, сумматор, логический инвертор, порт вывода, счётчик команд и т.д.)

Во время каждой фазы исполнения компоненту-источнику подаётся сигнал поместить данные на внутреннюю шину ЦП, а компоненту приёмнику - зафиксировать данные с шины в себе. В качестве простого примера можно привести функциональный аналог JUMP; логика обработки инструкций ЦП сигнализирует компоненту-источнику поместить данные на внутреннюю шину и в то же время сигнализирует счётчику команд зафиксировать эти данные в себе.

Единственный недостаток дизайна без микрокода заключается в отсутствии более сложных функций ЦП (стек, обработка прерываний и т.д.), хотя стек может быть эмулирован программно: в некоторых библиотеках используется одни из верхних адресов памяти данных как указатель стека и в макросе ассемблера реализуются PUSH, PULL, CALL и RET.

# Логика управления ЦП

Управляющая логика ЦП состоит из четырёх компонентов:

1.	Логика фаз ЦП
2.	Счётчик команд (PC)
3.	Регистр инструкций
4.	Декодер инструкций

## Логика фаз ЦП

Логика фаз отвечает за подачу сигналов фаз для ЦП. Один цикл выполнения инструкции ЦП состоит из 4 фаз независимо от длины инструкции (1 или 2 байта). Две из четырёх фаз являются фазами бездействия, в основном предназначенные для предотвращения глюков во время перехода от фазы выборки к фазе выполнения. Схема фаз построена на двухбитном счётчике (ТМ2).

Фазы ЦП:

<ol start="0">
<li>Бездействие
<li>Выборка
<ul>
<li>Побуждение памяти программ поместить следующеую инструкцию на внутреннюю шину ЦП
<li>Побуждение регистра инструкций зафиксировать инструкцию
<li>Инкремент счётчика команд (PC)
</ul>
<li>Бездействие
<li>Выполнение
<ul>
<li>Активация декодера инструкций для выполнения инструкций с помощью стробирования по /OE и /WE соответствующих компонентов источника и назначения
<li>Инкремент PC, если источником данных была память программ
</ul>
</ol>

Диаграммы сигналов фаз во время каждой фазы.

	Phase LSB
	--------+        +--------+
	        |        |        |
	        +--------+        +--------+
	
	
	Phase MSB
	-----------------+
	                 |
	                 +-----------------+
	
	
	Inverted MSB
	                 +-----------------+
	                 |
	-----------------+
	
	    0.      1.       2.       3.


## Счётчик команд

Счётчик команд собран из микросхем параллельно-загружаемых счётчиков (ИЕ10). Если расширить их количество до четырёх, то адресное пространство памяти программ составит 64К. Для загрузки данных в верхние 8 бит PC, был добавлен регистр расширения (ИР27/ТМ8 для 4 бит). Этот регистр загружается Наиболее Значащим Байтом адреса перед каждой инструкцией JMP, его содержимое загружается в верхние счётчики в то же время когда нижние 8 бит загружаются напрямую из внутренней шины данных ЦП.

PC инкрементируется автоматически после каждого чтения памяти программ (выборка инструкции или чтение константы из памяти программ)

## Регистр инструкций

Регистр инструкций представляет собой тактируемый фронтом D триггер (ИР27), в этот регистр загружаются данные во время каждой фазы выборки. Простейший способ представить фазу выборки - как специальную инструкцию MOVE на аппаратном уровне; источник данных всегда память программ, и приёмник всегда регистр инструкций.

## Декодер инструкций

Декодер инструкций собран из двух микросхем демультиплексоров (ИД4) и управляется регистром инструкций. Слово инструкций ЦП имеет размер 8 бит, 3 бита выбирают источник данных и 3 бита - приёмник. Каждая микросхема демультиплексора формирует сигналы управления для выбранных источника и приёмника данных во время фазы выполнения (фаза 3.).

Декодер инструкций использует 6 бит слова инструкции, оставшиеся 2 бита использованы для модификации инструкций:

*	Один бит указывает на условное (при нуле) выполнение; когда этот бит сброшен, инструкция будет выполнена только тогда, когда значение аккумулятора будет равно нулю. Это достигается просто запретом демультиплексора приёмников в случае, если содержимое аккумулятора ненулевое. Когда этот бит установлен, демультиплексор приёмников данных всегда работает, не зависимо от содержимого аккумулятора. (Заметка: демультиплексор источников данных не должен запрещаться; если источником данных служит память программ, ЦП, ожидаемо, увеличит PC независимо от того, была ли инструкция выполнена или нет. По этой причине, сигнал источникам данных всегда должен быть отправлен, чтобы счётчик команд мог обнаружить, что источником была память программ и мог увеличить PC автоматически).

*	Другой бит используется, чтобы реализовать хитрую возможность; если он установлен, выход переноса сумматора (ИМ6) с MSB перенаправляется на вход переноса в LSB. Вот зачем это нужно: ЦП не имеет побитового сдвига, единственные функции АЛУ это сложение и побитная инверсия. Для выполнения сдвига влево нужно сложить содержимое аккумулятора с ним же. Тогда, когда происходит возврат переноса, выполняется вращение байта; чтобы циклически сдвинуть биты, нужно просто сложить содержимое аккумулятора с ним же (сдвиг влево) и указать возврат переноса. Перенос из MSB вернётся в LSB и результат будет такой же, как циклический сдвиг влево. Можно выполнить циклический сдвиг вправо семикратным циклическим сдвигом влево; и, для полноты, можно выполнить сдвиг вправо семикратным циклическим сдвигом и простым сдвигом влево; а так как можно сравнивать два значения (вычитанием и выполнением при нулевом результате), можно также реализовать побитовое И и побитовое ИЛИ.

Отсутствие поддержки аппаратного циклического сдвига, побитовых И и ИЛИ на каком-либо ЦП совершенно неслыханно, но на самом деле это наименее используемые функции; с точки зрения программирования сложение и вычитание являются наиболее часто используемыми функциями.

# Пути передачи данных АЛУ и аккумулятора

Все функциональные возможности АЛУ реализованы с помощью двух 4-битных полных сумматоров (ИМ6) и побитового инвертора (АП3). Хотя процессор поддерживает только сложение и побитовое отрицание, теоретически все основные логические и арифметические функции могут быть реализованы алгоритмами, что делает этот процессор полностью завершенным по Тьюрингу.

Аккумулятор может быть загружен данными по 3 различным путям: 1) непосредственно через "чистый" буфер АП5, 2) через побитовый инвертор АП3, 3) и через сумматор. Один из операндов сумматора всегда является предыдущим значением аккумулятора; другой операнд поступает из внутренней шины данных процессора от любого компонента процессора (даже от аккумулятора, что приводит к операции "x2" или "побитовый сдвиг/циклический сдвиг влево") или входного порта.

Детектор нуля реализован 8-входовым диодным элементом ИЛИ. Его выходные данные используются, когда бит условного выполнения устанавливается равным нулю в коде операции.

# Другие схемы управления и периферийные устройства

ЦП имеет схему пуска-останова (RS-триггер, состоящий из дискретных вентилей) чтобы подавить тактирование генератором и сделать память программ доступной для программирования. При останове фазовая схема процессора останется в фазе 0. или 1. (фазовая защелка MSB будет постоянно находиться в состоянии сброса). Так как фаза 1. это фаза выборки, и PC инкрементируется в конце каждой фазы выборки, создание фазового перехода 1. -> 0. переключением кнопки PC\_INC является простым способом инкремента PC при вводе программы. Запись в память программ может быть выполнена только во время фазы 0. и кнопка PC\_INC должна быть нажата дважды после каждой записи (не элегантно, но реализация очень проста).

У ЦП нет отдельной схемы/буфера порта ввода. Несколько резисторов передают логическое состояние входного порта на внутреннюю шину данных, когда выходы всех других компонентов находятся в третьем состоянии.

Источник тактовых импульсов представляет собой базовый релаксационный генератор переменной частоты, состоящий из триггера Шмитта (ТЛ2), конденсатора и подстроечного резистора.

# Набор инструкций
<pre>
        7        6        5        4        3        2        1        0
    +--------+--------+--------+--------+--------+--------+--------+--------+
    |Carry fb| On Zero|  Src_0 |  Src_1 |  Src_2 |  Dst_0 |  Dst_1 |  Dst_2 |
    +--------+--------+--------+--------+--------+--------+--------+--------+



Data Sources:
=============

accumulator                (0b000)
ram                        (0b101)
literal                    (0b100)   (literal 8 bit data has to be placed right after the opcode)

    selecting any other data sources will leave the outputs of
    all component in High-Z state, making it available to read
    the input port


Data Destinations:
==================

accumulator                (0b000)
accumulator via inverter   (0b100)
accumulator via adder      (0b010)
output port                (0b110)
ram address latch          (0b001)
ram                        (0b101)
pc high latch              (0b111)
pc                         (0b011)   (contents of pc high latch will also be loaded into PC)


Instruction modifiers:
======================

'On zero' bit:
    Skip executing if the contents of the accumulator is not zero


'Carry feedback' bit:
    Feed back the carry output of the 8th bit of the adder to the carry input of the 1st bit.
</pre>

# Программирование

ЦП может быть запрограммирован с помощью пользовательского набора инструментов. Он состоит из ассемблера, Си-подобного компилятора и некоторых других инструментов. Си-подобный компилятор реализует базовое подмножество стандарта языка C, но с рядом ограничений (например, нет структур, нет массивов, нет "строк" и т. д.) и ассемблер также является базовым, он просто обеспечивает достаточную функциональность, чтобы заставить C-подобный компилятор работать на этой платформе.
Процессор не имеет указателя стека, а также инструкций по манипулированию стеком (push, pop, call и ret), поэтому функциональность стека реализована с помощью некоторых базовых макросов сборки. Одно из самых верхних мест памяти назначается в качестве указателя стека, макросы в основном загружают его значение в аккумулятор (после сохранения его содержимого, если это необходимо), увеличивают/уменьшают его, а затем возвращают обратно. Дополнительный трюк необходим для инструкции "call", где адрес возврата должен быть сохранён в стеке; Можно использовать отдельные метки, которые указывают на следующую инструкцию после "call" и сохранять в стеке их.
В целом, каждая команда манипулирования стеком выполняется 12-14 командами ЦП, поэтому их использование чрезвычайно потребляет память; обычно эти функции находятся в микрокоде, программисту не нужно говорить процессору, что именно делать каждый раз, когда вызывается функция; (однако у версии с адресным пространством 64k трудно истощить память программы, и процессор остается простым, а его архитектура полностью определяется аппаратным обеспечением).
Процессор также не имеет стандартного АЛУ, но у него есть всё, чтобы вычислить любые основные арифметические и логические функции. Побитовая функциональность AND реализована в подпрограмме (то есть компилятор фактически вызывает ее с помощью инструкции 'call'), поскольку она была бы слишком велика, чтобы помещать ее в программу при каждом вызове в виде макроса (это 64-шаговый алгоритм)


